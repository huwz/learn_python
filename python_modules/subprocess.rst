subprocess模块
==============

对于脚本 ``D:\hello.py``:

.. code-block:: Python

   #-*- coding -*-

   ''' Python 2.7.x '''
   print 'hello,world'

使用 subprocess 模块执行该脚本：

.. code-block:: Python

 subprocess.call(r'cmd /C "D:\1.py"') #表示另外打开一个命令行窗口执行脚本，脚本执行状态码通过该函数返回

.. code-block:: Python

 subprocess.call(r"D:\1.py", shell=True) #如果 1.py处在当前目录，则可以省略 shell 参数

对于具有命令行特性的指令，shell 参数必须设为True(其余的情况下可以省略不写( shell = False ))

* 命令行内部命令（比如 Windows 命令行指令 type）
* 需要搜索路径的程序，例如上面的例子

``subprocess.Popen()``
----------------------

这个函数的参数特别多，除第一个参数 ``args`` 之外，其余的都是关键字参数 [1]_。
简单起见，只拣常用的参数介绍：

* args 字符串或者参数序列。
  
  字符串或者参数序列的第一个元素指明要执行的程序路径；
  也可以使用可执行参数显示地设置。
  例如：

  .. code-block:: Python
    :linenos:

    subprocess.Popen("Python.exe 1.py") #显示
    subprocess.Popen("1.py") #隐式
* shell
  
  +---------+------------+----------------------------------------------------------+---------------------------------+
  | os      | shell      | args                                                     | 说明                            |
  +=========+============+==========================================================+=================================+
  | Unix    | False      | 序列/字符串(程序不能有参数)                              | os.execvp() 执行子程序          |
  +---------+------------+----------------------------------------------------------+---------------------------------+
  | Unix    | True       | * 字符串，和在命令窗口中执行的命令完全一致               | 命令行通过外部参数构建，        |
  |         |            | * 序列，第一个元素是命令字符串，其余元素作为命令行的参数 | 则不推荐使用 shell=True [2]_    |
  +---------+------------+----------------------------------------------------------+---------------------------------+
  | Windows | False/True | * 字符串，和在命令窗口中执行的命令完全一致               | 调用 CreateProcess() 执行子程序 |
  |         |            | * 序列，按照一定的规则转化为命令行字符串                 |                                 |
  +---------+------------+----------------------------------------------------------+---------------------------------+
		
* stdin, stdout, stderr
  
  指定程序标准输入流，输出流和错误流文件句柄。
  可以取 PIPE, 现有文件描述符（正整数），现有文件对象以及None。
  PIPE 表示给子程序创建一个新的管道；None 表示不进行流重定向，完全继承于父进程。
  另外，*stderr* 可以设为 STDOUT，表示程序捕捉的错误文本信息会进入标准输出流。

* return 一个 ``Popen`` 对象

``subprocess.PIPE``
-------------------

可以作为参数 stdin/stdout/stderr 的值传递给 ``Popen()``。
函数返回一个管道对象，用于连接相应的标准流。

``subprocess.STDOUT``
---------------------

可以作为参数 stderr 的值传递给 ``Popen()``。
函数返回一个管道对象，用于连接标准输出流和标准出错流。

``Popen`` 类
------------

+---------------------------+-----------------------------------------------------------------+
| class members             | function                                                        |
+===========================+=================================================================+
| Popen.poll()              | 检测子进程是否结束，设置并返回 **returncode** 属性              |
+---------------------------+-----------------------------------------------------------------+
| Popen.wait()              | 等待子进程结束，设置并返回 **returncode** 属性                  |
+---------------------------+-----------------------------------------------------------------+
| Popen.communicate         | * 发送数据到 stdin。                                            |
| (input=None)              | * 从 stdout 和 stderr 中读取数据，遇到文件结束符为止。          |
|                           | * 等待进程结束。                                                |
|                           | * 参数是字符串，传给子进程                                      |
|                           | * 返回元组(stdoutdata, stderrdata)                              |
+---------------------------+-----------------------------------------------------------------+
| Popen.check_output        | 执行带参数的命令行，结果以字节数组返回                          |
| (\*popenargs, \*\*kwargs) |                                                                 |
+---------------------------+-----------------------------------------------------------------+
| Popen.send_signal         | * SIGTERM(Windows 中是 terminate() 的别名)                      |
| (signal)                  | * CTRL_C_EVENT   CTRL + C 按键消息                              |
|                           | * CTRL_BREAK_EVENT .etc                                         |
+---------------------------+-----------------------------------------------------------------+
| Popen.terminate()         | 结束子进程，在 Posix 操作系统中，发送 SIGTERM 消息给子进程      |
|                           | 在 Windows 操作系统中，使用系统 API TerminateProcess() 结束进程 |
+---------------------------+-----------------------------------------------------------------+
| Popen.kill()              | * Windows 系统中，是 terminate() 的别名                         |
|                           | * Posix 系统中，发送 SIGKILL 给子进程                           |
+---------------------------+-----------------------------------------------------------------+
| Popen.stdin               | stdin=PIPE，则该属性是一个文件对象，为子进程提供输入；          |
|                           | stdin=None，则为 None                                           |
+---------------------------+-----------------------------------------------------------------+
| Popen.stdout              | stdin=PIPE，则该属性是一个文件对象，获取子进程的输出；          |
|                           | stdin=None，则为 None                                           |
+---------------------------+-----------------------------------------------------------------+
| Popen.stderr              | stdin=PIPE，则该属性是一个文件对象，获取子进程的错误信息；      |
|                           | stdin=None，则为 None                                           |
+---------------------------+-----------------------------------------------------------------+
| Popen.pid                 | shell=False，子进程的进程 ID                                    |
|                           | shell=True，命令窗的进程 ID                                     |
+---------------------------+-----------------------------------------------------------------+
| Popen.returncode          | 子进程的返回码，通过 ``poll()`` 和 ``wait()`` 设置；            |
|                           | 间接通过 ``communicate()`` 设置；                               |
|                           | 为 None，表示子进程并未结束                                     |
+---------------------------+-----------------------------------------------------------------+


.. warning:: 使用 stdout=PIPE / stderr=PIPE 时，Popen.wait() 会产生死锁；
 子进程产生的输出信息太多，会因等待OS管道缓冲区接收数据而阻塞。
 communicate() 可以避免这个问题。




.. [1] 诸如：a = 0 这种形式的参数
.. [2] 涉及到到命令行注入问题（即可以外部编辑命令行），命令行注入允许用户越权使用任意指令。